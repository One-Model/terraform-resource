// Code generated by counterfeiter. DO NOT EDIT.
package terraformfakes

import (
	"sync"

	"github.com/ljfranklin/terraform-resource/models"
	"github.com/ljfranklin/terraform-resource/terraform"
)

type FakeClient struct {
	ApplyStub        func() error
	applyMutex       sync.RWMutex
	applyArgsForCall []struct {
	}
	applyReturns struct {
		result1 error
	}
	applyReturnsOnCall map[int]struct {
		result1 error
	}
	CurrentStateVersionStub        func(string) (terraform.StateVersion, error)
	currentStateVersionMutex       sync.RWMutex
	currentStateVersionArgsForCall []struct {
		arg1 string
	}
	currentStateVersionReturns struct {
		result1 terraform.StateVersion
		result2 error
	}
	currentStateVersionReturnsOnCall map[int]struct {
		result1 terraform.StateVersion
		result2 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct {
	}
	destroyReturns struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	GetPlanFromBackendStub        func(string) error
	getPlanFromBackendMutex       sync.RWMutex
	getPlanFromBackendArgsForCall []struct {
		arg1 string
	}
	getPlanFromBackendReturns struct {
		result1 error
	}
	getPlanFromBackendReturnsOnCall map[int]struct {
		result1 error
	}
	ImportStub        func(string) error
	importMutex       sync.RWMutex
	importArgsForCall []struct {
		arg1 string
	}
	importReturns struct {
		result1 error
	}
	importReturnsOnCall map[int]struct {
		result1 error
	}
	ImportWithLegacyStorageStub        func() error
	importWithLegacyStorageMutex       sync.RWMutex
	importWithLegacyStorageArgsForCall []struct {
	}
	importWithLegacyStorageReturns struct {
		result1 error
	}
	importWithLegacyStorageReturnsOnCall map[int]struct {
		result1 error
	}
	InitWithBackendStub        func(string) error
	initWithBackendMutex       sync.RWMutex
	initWithBackendArgsForCall []struct {
		arg1 string
	}
	initWithBackendReturns struct {
		result1 error
	}
	initWithBackendReturnsOnCall map[int]struct {
		result1 error
	}
	InitWithoutBackendStub        func() error
	initWithoutBackendMutex       sync.RWMutex
	initWithoutBackendArgsForCall []struct {
	}
	initWithoutBackendReturns struct {
		result1 error
	}
	initWithoutBackendReturnsOnCall map[int]struct {
		result1 error
	}
	JSONPlanStub        func() error
	jSONPlanMutex       sync.RWMutex
	jSONPlanArgsForCall []struct {
	}
	jSONPlanReturns struct {
		result1 error
	}
	jSONPlanReturnsOnCall map[int]struct {
		result1 error
	}
	OutputStub        func(string) (map[string]map[string]interface{}, error)
	outputMutex       sync.RWMutex
	outputArgsForCall []struct {
		arg1 string
	}
	outputReturns struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	outputReturnsOnCall map[int]struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	OutputWithLegacyStorageStub        func() (map[string]map[string]interface{}, error)
	outputWithLegacyStorageMutex       sync.RWMutex
	outputWithLegacyStorageArgsForCall []struct {
	}
	outputWithLegacyStorageReturns struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	outputWithLegacyStorageReturnsOnCall map[int]struct {
		result1 map[string]map[string]interface{}
		result2 error
	}
	PlanStub        func() (string, error)
	planMutex       sync.RWMutex
	planArgsForCall []struct {
	}
	planReturns struct {
		result1 string
		result2 error
	}
	planReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SavePlanToBackendStub        func(string) error
	savePlanToBackendMutex       sync.RWMutex
	savePlanToBackendArgsForCall []struct {
		arg1 string
	}
	savePlanToBackendReturns struct {
		result1 error
	}
	savePlanToBackendReturnsOnCall map[int]struct {
		result1 error
	}
	SetModelStub        func(models.Terraform)
	setModelMutex       sync.RWMutex
	setModelArgsForCall []struct {
		arg1 models.Terraform
	}
	StatePullStub        func(string) ([]byte, error)
	statePullMutex       sync.RWMutex
	statePullArgsForCall []struct {
		arg1 string
	}
	statePullReturns struct {
		result1 []byte
		result2 error
	}
	statePullReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	VersionStub        func() (string, error)
	versionMutex       sync.RWMutex
	versionArgsForCall []struct {
	}
	versionReturns struct {
		result1 string
		result2 error
	}
	versionReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	WorkspaceDeleteStub        func(string) error
	workspaceDeleteMutex       sync.RWMutex
	workspaceDeleteArgsForCall []struct {
		arg1 string
	}
	workspaceDeleteReturns struct {
		result1 error
	}
	workspaceDeleteReturnsOnCall map[int]struct {
		result1 error
	}
	WorkspaceDeleteWithForceStub        func(string) error
	workspaceDeleteWithForceMutex       sync.RWMutex
	workspaceDeleteWithForceArgsForCall []struct {
		arg1 string
	}
	workspaceDeleteWithForceReturns struct {
		result1 error
	}
	workspaceDeleteWithForceReturnsOnCall map[int]struct {
		result1 error
	}
	WorkspaceListStub        func() ([]string, error)
	workspaceListMutex       sync.RWMutex
	workspaceListArgsForCall []struct {
	}
	workspaceListReturns struct {
		result1 []string
		result2 error
	}
	workspaceListReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	WorkspaceNewFromExistingStateFileStub        func(string, string) error
	workspaceNewFromExistingStateFileMutex       sync.RWMutex
	workspaceNewFromExistingStateFileArgsForCall []struct {
		arg1 string
		arg2 string
	}
	workspaceNewFromExistingStateFileReturns struct {
		result1 error
	}
	workspaceNewFromExistingStateFileReturnsOnCall map[int]struct {
		result1 error
	}
	WorkspaceNewIfNotExistsStub        func(string) error
	workspaceNewIfNotExistsMutex       sync.RWMutex
	workspaceNewIfNotExistsArgsForCall []struct {
		arg1 string
	}
	workspaceNewIfNotExistsReturns struct {
		result1 error
	}
	workspaceNewIfNotExistsReturnsOnCall map[int]struct {
		result1 error
	}
	WorkspaceSelectStub        func(string) error
	workspaceSelectMutex       sync.RWMutex
	workspaceSelectArgsForCall []struct {
		arg1 string
	}
	workspaceSelectReturns struct {
		result1 error
	}
	workspaceSelectReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) Apply() error {
	fake.applyMutex.Lock()
	ret, specificReturn := fake.applyReturnsOnCall[len(fake.applyArgsForCall)]
	fake.applyArgsForCall = append(fake.applyArgsForCall, struct {
	}{})
	stub := fake.ApplyStub
	fakeReturns := fake.applyReturns
	fake.recordInvocation("Apply", []interface{}{})
	fake.applyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ApplyCallCount() int {
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	return len(fake.applyArgsForCall)
}

func (fake *FakeClient) ApplyCalls(stub func() error) {
	fake.applyMutex.Lock()
	defer fake.applyMutex.Unlock()
	fake.ApplyStub = stub
}

func (fake *FakeClient) ApplyReturns(result1 error) {
	fake.applyMutex.Lock()
	defer fake.applyMutex.Unlock()
	fake.ApplyStub = nil
	fake.applyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ApplyReturnsOnCall(i int, result1 error) {
	fake.applyMutex.Lock()
	defer fake.applyMutex.Unlock()
	fake.ApplyStub = nil
	if fake.applyReturnsOnCall == nil {
		fake.applyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.applyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) CurrentStateVersion(arg1 string) (terraform.StateVersion, error) {
	fake.currentStateVersionMutex.Lock()
	ret, specificReturn := fake.currentStateVersionReturnsOnCall[len(fake.currentStateVersionArgsForCall)]
	fake.currentStateVersionArgsForCall = append(fake.currentStateVersionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.CurrentStateVersionStub
	fakeReturns := fake.currentStateVersionReturns
	fake.recordInvocation("CurrentStateVersion", []interface{}{arg1})
	fake.currentStateVersionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CurrentStateVersionCallCount() int {
	fake.currentStateVersionMutex.RLock()
	defer fake.currentStateVersionMutex.RUnlock()
	return len(fake.currentStateVersionArgsForCall)
}

func (fake *FakeClient) CurrentStateVersionCalls(stub func(string) (terraform.StateVersion, error)) {
	fake.currentStateVersionMutex.Lock()
	defer fake.currentStateVersionMutex.Unlock()
	fake.CurrentStateVersionStub = stub
}

func (fake *FakeClient) CurrentStateVersionArgsForCall(i int) string {
	fake.currentStateVersionMutex.RLock()
	defer fake.currentStateVersionMutex.RUnlock()
	argsForCall := fake.currentStateVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) CurrentStateVersionReturns(result1 terraform.StateVersion, result2 error) {
	fake.currentStateVersionMutex.Lock()
	defer fake.currentStateVersionMutex.Unlock()
	fake.CurrentStateVersionStub = nil
	fake.currentStateVersionReturns = struct {
		result1 terraform.StateVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CurrentStateVersionReturnsOnCall(i int, result1 terraform.StateVersion, result2 error) {
	fake.currentStateVersionMutex.Lock()
	defer fake.currentStateVersionMutex.Unlock()
	fake.CurrentStateVersionStub = nil
	if fake.currentStateVersionReturnsOnCall == nil {
		fake.currentStateVersionReturnsOnCall = make(map[int]struct {
			result1 terraform.StateVersion
			result2 error
		})
	}
	fake.currentStateVersionReturnsOnCall[i] = struct {
		result1 terraform.StateVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Destroy() error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct {
	}{})
	stub := fake.DestroyStub
	fakeReturns := fake.destroyReturns
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakeClient) DestroyCalls(stub func() error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = stub
}

func (fake *FakeClient) DestroyReturns(result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) DestroyReturnsOnCall(i int, result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetPlanFromBackend(arg1 string) error {
	fake.getPlanFromBackendMutex.Lock()
	ret, specificReturn := fake.getPlanFromBackendReturnsOnCall[len(fake.getPlanFromBackendArgsForCall)]
	fake.getPlanFromBackendArgsForCall = append(fake.getPlanFromBackendArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetPlanFromBackendStub
	fakeReturns := fake.getPlanFromBackendReturns
	fake.recordInvocation("GetPlanFromBackend", []interface{}{arg1})
	fake.getPlanFromBackendMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) GetPlanFromBackendCallCount() int {
	fake.getPlanFromBackendMutex.RLock()
	defer fake.getPlanFromBackendMutex.RUnlock()
	return len(fake.getPlanFromBackendArgsForCall)
}

func (fake *FakeClient) GetPlanFromBackendCalls(stub func(string) error) {
	fake.getPlanFromBackendMutex.Lock()
	defer fake.getPlanFromBackendMutex.Unlock()
	fake.GetPlanFromBackendStub = stub
}

func (fake *FakeClient) GetPlanFromBackendArgsForCall(i int) string {
	fake.getPlanFromBackendMutex.RLock()
	defer fake.getPlanFromBackendMutex.RUnlock()
	argsForCall := fake.getPlanFromBackendArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) GetPlanFromBackendReturns(result1 error) {
	fake.getPlanFromBackendMutex.Lock()
	defer fake.getPlanFromBackendMutex.Unlock()
	fake.GetPlanFromBackendStub = nil
	fake.getPlanFromBackendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) GetPlanFromBackendReturnsOnCall(i int, result1 error) {
	fake.getPlanFromBackendMutex.Lock()
	defer fake.getPlanFromBackendMutex.Unlock()
	fake.GetPlanFromBackendStub = nil
	if fake.getPlanFromBackendReturnsOnCall == nil {
		fake.getPlanFromBackendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.getPlanFromBackendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Import(arg1 string) error {
	fake.importMutex.Lock()
	ret, specificReturn := fake.importReturnsOnCall[len(fake.importArgsForCall)]
	fake.importArgsForCall = append(fake.importArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ImportStub
	fakeReturns := fake.importReturns
	fake.recordInvocation("Import", []interface{}{arg1})
	fake.importMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ImportCallCount() int {
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	return len(fake.importArgsForCall)
}

func (fake *FakeClient) ImportCalls(stub func(string) error) {
	fake.importMutex.Lock()
	defer fake.importMutex.Unlock()
	fake.ImportStub = stub
}

func (fake *FakeClient) ImportArgsForCall(i int) string {
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	argsForCall := fake.importArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) ImportReturns(result1 error) {
	fake.importMutex.Lock()
	defer fake.importMutex.Unlock()
	fake.ImportStub = nil
	fake.importReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ImportReturnsOnCall(i int, result1 error) {
	fake.importMutex.Lock()
	defer fake.importMutex.Unlock()
	fake.ImportStub = nil
	if fake.importReturnsOnCall == nil {
		fake.importReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.importReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ImportWithLegacyStorage() error {
	fake.importWithLegacyStorageMutex.Lock()
	ret, specificReturn := fake.importWithLegacyStorageReturnsOnCall[len(fake.importWithLegacyStorageArgsForCall)]
	fake.importWithLegacyStorageArgsForCall = append(fake.importWithLegacyStorageArgsForCall, struct {
	}{})
	stub := fake.ImportWithLegacyStorageStub
	fakeReturns := fake.importWithLegacyStorageReturns
	fake.recordInvocation("ImportWithLegacyStorage", []interface{}{})
	fake.importWithLegacyStorageMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) ImportWithLegacyStorageCallCount() int {
	fake.importWithLegacyStorageMutex.RLock()
	defer fake.importWithLegacyStorageMutex.RUnlock()
	return len(fake.importWithLegacyStorageArgsForCall)
}

func (fake *FakeClient) ImportWithLegacyStorageCalls(stub func() error) {
	fake.importWithLegacyStorageMutex.Lock()
	defer fake.importWithLegacyStorageMutex.Unlock()
	fake.ImportWithLegacyStorageStub = stub
}

func (fake *FakeClient) ImportWithLegacyStorageReturns(result1 error) {
	fake.importWithLegacyStorageMutex.Lock()
	defer fake.importWithLegacyStorageMutex.Unlock()
	fake.ImportWithLegacyStorageStub = nil
	fake.importWithLegacyStorageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) ImportWithLegacyStorageReturnsOnCall(i int, result1 error) {
	fake.importWithLegacyStorageMutex.Lock()
	defer fake.importWithLegacyStorageMutex.Unlock()
	fake.ImportWithLegacyStorageStub = nil
	if fake.importWithLegacyStorageReturnsOnCall == nil {
		fake.importWithLegacyStorageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.importWithLegacyStorageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithBackend(arg1 string) error {
	fake.initWithBackendMutex.Lock()
	ret, specificReturn := fake.initWithBackendReturnsOnCall[len(fake.initWithBackendArgsForCall)]
	fake.initWithBackendArgsForCall = append(fake.initWithBackendArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.InitWithBackendStub
	fakeReturns := fake.initWithBackendReturns
	fake.recordInvocation("InitWithBackend", []interface{}{arg1})
	fake.initWithBackendMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) InitWithBackendCallCount() int {
	fake.initWithBackendMutex.RLock()
	defer fake.initWithBackendMutex.RUnlock()
	return len(fake.initWithBackendArgsForCall)
}

func (fake *FakeClient) InitWithBackendCalls(stub func(string) error) {
	fake.initWithBackendMutex.Lock()
	defer fake.initWithBackendMutex.Unlock()
	fake.InitWithBackendStub = stub
}

func (fake *FakeClient) InitWithBackendArgsForCall(i int) string {
	fake.initWithBackendMutex.RLock()
	defer fake.initWithBackendMutex.RUnlock()
	argsForCall := fake.initWithBackendArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) InitWithBackendReturns(result1 error) {
	fake.initWithBackendMutex.Lock()
	defer fake.initWithBackendMutex.Unlock()
	fake.InitWithBackendStub = nil
	fake.initWithBackendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithBackendReturnsOnCall(i int, result1 error) {
	fake.initWithBackendMutex.Lock()
	defer fake.initWithBackendMutex.Unlock()
	fake.InitWithBackendStub = nil
	if fake.initWithBackendReturnsOnCall == nil {
		fake.initWithBackendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initWithBackendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithoutBackend() error {
	fake.initWithoutBackendMutex.Lock()
	ret, specificReturn := fake.initWithoutBackendReturnsOnCall[len(fake.initWithoutBackendArgsForCall)]
	fake.initWithoutBackendArgsForCall = append(fake.initWithoutBackendArgsForCall, struct {
	}{})
	stub := fake.InitWithoutBackendStub
	fakeReturns := fake.initWithoutBackendReturns
	fake.recordInvocation("InitWithoutBackend", []interface{}{})
	fake.initWithoutBackendMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) InitWithoutBackendCallCount() int {
	fake.initWithoutBackendMutex.RLock()
	defer fake.initWithoutBackendMutex.RUnlock()
	return len(fake.initWithoutBackendArgsForCall)
}

func (fake *FakeClient) InitWithoutBackendCalls(stub func() error) {
	fake.initWithoutBackendMutex.Lock()
	defer fake.initWithoutBackendMutex.Unlock()
	fake.InitWithoutBackendStub = stub
}

func (fake *FakeClient) InitWithoutBackendReturns(result1 error) {
	fake.initWithoutBackendMutex.Lock()
	defer fake.initWithoutBackendMutex.Unlock()
	fake.InitWithoutBackendStub = nil
	fake.initWithoutBackendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) InitWithoutBackendReturnsOnCall(i int, result1 error) {
	fake.initWithoutBackendMutex.Lock()
	defer fake.initWithoutBackendMutex.Unlock()
	fake.InitWithoutBackendStub = nil
	if fake.initWithoutBackendReturnsOnCall == nil {
		fake.initWithoutBackendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initWithoutBackendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) JSONPlan() error {
	fake.jSONPlanMutex.Lock()
	ret, specificReturn := fake.jSONPlanReturnsOnCall[len(fake.jSONPlanArgsForCall)]
	fake.jSONPlanArgsForCall = append(fake.jSONPlanArgsForCall, struct {
	}{})
	stub := fake.JSONPlanStub
	fakeReturns := fake.jSONPlanReturns
	fake.recordInvocation("JSONPlan", []interface{}{})
	fake.jSONPlanMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) JSONPlanCallCount() int {
	fake.jSONPlanMutex.RLock()
	defer fake.jSONPlanMutex.RUnlock()
	return len(fake.jSONPlanArgsForCall)
}

func (fake *FakeClient) JSONPlanCalls(stub func() error) {
	fake.jSONPlanMutex.Lock()
	defer fake.jSONPlanMutex.Unlock()
	fake.JSONPlanStub = stub
}

func (fake *FakeClient) JSONPlanReturns(result1 error) {
	fake.jSONPlanMutex.Lock()
	defer fake.jSONPlanMutex.Unlock()
	fake.JSONPlanStub = nil
	fake.jSONPlanReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) JSONPlanReturnsOnCall(i int, result1 error) {
	fake.jSONPlanMutex.Lock()
	defer fake.jSONPlanMutex.Unlock()
	fake.JSONPlanStub = nil
	if fake.jSONPlanReturnsOnCall == nil {
		fake.jSONPlanReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.jSONPlanReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Output(arg1 string) (map[string]map[string]interface{}, error) {
	fake.outputMutex.Lock()
	ret, specificReturn := fake.outputReturnsOnCall[len(fake.outputArgsForCall)]
	fake.outputArgsForCall = append(fake.outputArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.OutputStub
	fakeReturns := fake.outputReturns
	fake.recordInvocation("Output", []interface{}{arg1})
	fake.outputMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) OutputCallCount() int {
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	return len(fake.outputArgsForCall)
}

func (fake *FakeClient) OutputCalls(stub func(string) (map[string]map[string]interface{}, error)) {
	fake.outputMutex.Lock()
	defer fake.outputMutex.Unlock()
	fake.OutputStub = stub
}

func (fake *FakeClient) OutputArgsForCall(i int) string {
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	argsForCall := fake.outputArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) OutputReturns(result1 map[string]map[string]interface{}, result2 error) {
	fake.outputMutex.Lock()
	defer fake.outputMutex.Unlock()
	fake.OutputStub = nil
	fake.outputReturns = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OutputReturnsOnCall(i int, result1 map[string]map[string]interface{}, result2 error) {
	fake.outputMutex.Lock()
	defer fake.outputMutex.Unlock()
	fake.OutputStub = nil
	if fake.outputReturnsOnCall == nil {
		fake.outputReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string]interface{}
			result2 error
		})
	}
	fake.outputReturnsOnCall[i] = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OutputWithLegacyStorage() (map[string]map[string]interface{}, error) {
	fake.outputWithLegacyStorageMutex.Lock()
	ret, specificReturn := fake.outputWithLegacyStorageReturnsOnCall[len(fake.outputWithLegacyStorageArgsForCall)]
	fake.outputWithLegacyStorageArgsForCall = append(fake.outputWithLegacyStorageArgsForCall, struct {
	}{})
	stub := fake.OutputWithLegacyStorageStub
	fakeReturns := fake.outputWithLegacyStorageReturns
	fake.recordInvocation("OutputWithLegacyStorage", []interface{}{})
	fake.outputWithLegacyStorageMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) OutputWithLegacyStorageCallCount() int {
	fake.outputWithLegacyStorageMutex.RLock()
	defer fake.outputWithLegacyStorageMutex.RUnlock()
	return len(fake.outputWithLegacyStorageArgsForCall)
}

func (fake *FakeClient) OutputWithLegacyStorageCalls(stub func() (map[string]map[string]interface{}, error)) {
	fake.outputWithLegacyStorageMutex.Lock()
	defer fake.outputWithLegacyStorageMutex.Unlock()
	fake.OutputWithLegacyStorageStub = stub
}

func (fake *FakeClient) OutputWithLegacyStorageReturns(result1 map[string]map[string]interface{}, result2 error) {
	fake.outputWithLegacyStorageMutex.Lock()
	defer fake.outputWithLegacyStorageMutex.Unlock()
	fake.OutputWithLegacyStorageStub = nil
	fake.outputWithLegacyStorageReturns = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) OutputWithLegacyStorageReturnsOnCall(i int, result1 map[string]map[string]interface{}, result2 error) {
	fake.outputWithLegacyStorageMutex.Lock()
	defer fake.outputWithLegacyStorageMutex.Unlock()
	fake.OutputWithLegacyStorageStub = nil
	if fake.outputWithLegacyStorageReturnsOnCall == nil {
		fake.outputWithLegacyStorageReturnsOnCall = make(map[int]struct {
			result1 map[string]map[string]interface{}
			result2 error
		})
	}
	fake.outputWithLegacyStorageReturnsOnCall[i] = struct {
		result1 map[string]map[string]interface{}
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Plan() (string, error) {
	fake.planMutex.Lock()
	ret, specificReturn := fake.planReturnsOnCall[len(fake.planArgsForCall)]
	fake.planArgsForCall = append(fake.planArgsForCall, struct {
	}{})
	stub := fake.PlanStub
	fakeReturns := fake.planReturns
	fake.recordInvocation("Plan", []interface{}{})
	fake.planMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) PlanCallCount() int {
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	return len(fake.planArgsForCall)
}

func (fake *FakeClient) PlanCalls(stub func() (string, error)) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = stub
}

func (fake *FakeClient) PlanReturns(result1 string, result2 error) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = nil
	fake.planReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) PlanReturnsOnCall(i int, result1 string, result2 error) {
	fake.planMutex.Lock()
	defer fake.planMutex.Unlock()
	fake.PlanStub = nil
	if fake.planReturnsOnCall == nil {
		fake.planReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.planReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) SavePlanToBackend(arg1 string) error {
	fake.savePlanToBackendMutex.Lock()
	ret, specificReturn := fake.savePlanToBackendReturnsOnCall[len(fake.savePlanToBackendArgsForCall)]
	fake.savePlanToBackendArgsForCall = append(fake.savePlanToBackendArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SavePlanToBackendStub
	fakeReturns := fake.savePlanToBackendReturns
	fake.recordInvocation("SavePlanToBackend", []interface{}{arg1})
	fake.savePlanToBackendMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) SavePlanToBackendCallCount() int {
	fake.savePlanToBackendMutex.RLock()
	defer fake.savePlanToBackendMutex.RUnlock()
	return len(fake.savePlanToBackendArgsForCall)
}

func (fake *FakeClient) SavePlanToBackendCalls(stub func(string) error) {
	fake.savePlanToBackendMutex.Lock()
	defer fake.savePlanToBackendMutex.Unlock()
	fake.SavePlanToBackendStub = stub
}

func (fake *FakeClient) SavePlanToBackendArgsForCall(i int) string {
	fake.savePlanToBackendMutex.RLock()
	defer fake.savePlanToBackendMutex.RUnlock()
	argsForCall := fake.savePlanToBackendArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) SavePlanToBackendReturns(result1 error) {
	fake.savePlanToBackendMutex.Lock()
	defer fake.savePlanToBackendMutex.Unlock()
	fake.SavePlanToBackendStub = nil
	fake.savePlanToBackendReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) SavePlanToBackendReturnsOnCall(i int, result1 error) {
	fake.savePlanToBackendMutex.Lock()
	defer fake.savePlanToBackendMutex.Unlock()
	fake.SavePlanToBackendStub = nil
	if fake.savePlanToBackendReturnsOnCall == nil {
		fake.savePlanToBackendReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.savePlanToBackendReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) SetModel(arg1 models.Terraform) {
	fake.setModelMutex.Lock()
	fake.setModelArgsForCall = append(fake.setModelArgsForCall, struct {
		arg1 models.Terraform
	}{arg1})
	stub := fake.SetModelStub
	fake.recordInvocation("SetModel", []interface{}{arg1})
	fake.setModelMutex.Unlock()
	if stub != nil {
		fake.SetModelStub(arg1)
	}
}

func (fake *FakeClient) SetModelCallCount() int {
	fake.setModelMutex.RLock()
	defer fake.setModelMutex.RUnlock()
	return len(fake.setModelArgsForCall)
}

func (fake *FakeClient) SetModelCalls(stub func(models.Terraform)) {
	fake.setModelMutex.Lock()
	defer fake.setModelMutex.Unlock()
	fake.SetModelStub = stub
}

func (fake *FakeClient) SetModelArgsForCall(i int) models.Terraform {
	fake.setModelMutex.RLock()
	defer fake.setModelMutex.RUnlock()
	argsForCall := fake.setModelArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) StatePull(arg1 string) ([]byte, error) {
	fake.statePullMutex.Lock()
	ret, specificReturn := fake.statePullReturnsOnCall[len(fake.statePullArgsForCall)]
	fake.statePullArgsForCall = append(fake.statePullArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StatePullStub
	fakeReturns := fake.statePullReturns
	fake.recordInvocation("StatePull", []interface{}{arg1})
	fake.statePullMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) StatePullCallCount() int {
	fake.statePullMutex.RLock()
	defer fake.statePullMutex.RUnlock()
	return len(fake.statePullArgsForCall)
}

func (fake *FakeClient) StatePullCalls(stub func(string) ([]byte, error)) {
	fake.statePullMutex.Lock()
	defer fake.statePullMutex.Unlock()
	fake.StatePullStub = stub
}

func (fake *FakeClient) StatePullArgsForCall(i int) string {
	fake.statePullMutex.RLock()
	defer fake.statePullMutex.RUnlock()
	argsForCall := fake.statePullArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) StatePullReturns(result1 []byte, result2 error) {
	fake.statePullMutex.Lock()
	defer fake.statePullMutex.Unlock()
	fake.StatePullStub = nil
	fake.statePullReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) StatePullReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.statePullMutex.Lock()
	defer fake.statePullMutex.Unlock()
	fake.StatePullStub = nil
	if fake.statePullReturnsOnCall == nil {
		fake.statePullReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.statePullReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Version() (string, error) {
	fake.versionMutex.Lock()
	ret, specificReturn := fake.versionReturnsOnCall[len(fake.versionArgsForCall)]
	fake.versionArgsForCall = append(fake.versionArgsForCall, struct {
	}{})
	stub := fake.VersionStub
	fakeReturns := fake.versionReturns
	fake.recordInvocation("Version", []interface{}{})
	fake.versionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) VersionCallCount() int {
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	return len(fake.versionArgsForCall)
}

func (fake *FakeClient) VersionCalls(stub func() (string, error)) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = stub
}

func (fake *FakeClient) VersionReturns(result1 string, result2 error) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	fake.versionReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) VersionReturnsOnCall(i int, result1 string, result2 error) {
	fake.versionMutex.Lock()
	defer fake.versionMutex.Unlock()
	fake.VersionStub = nil
	if fake.versionReturnsOnCall == nil {
		fake.versionReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.versionReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WorkspaceDelete(arg1 string) error {
	fake.workspaceDeleteMutex.Lock()
	ret, specificReturn := fake.workspaceDeleteReturnsOnCall[len(fake.workspaceDeleteArgsForCall)]
	fake.workspaceDeleteArgsForCall = append(fake.workspaceDeleteArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.WorkspaceDeleteStub
	fakeReturns := fake.workspaceDeleteReturns
	fake.recordInvocation("WorkspaceDelete", []interface{}{arg1})
	fake.workspaceDeleteMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) WorkspaceDeleteCallCount() int {
	fake.workspaceDeleteMutex.RLock()
	defer fake.workspaceDeleteMutex.RUnlock()
	return len(fake.workspaceDeleteArgsForCall)
}

func (fake *FakeClient) WorkspaceDeleteCalls(stub func(string) error) {
	fake.workspaceDeleteMutex.Lock()
	defer fake.workspaceDeleteMutex.Unlock()
	fake.WorkspaceDeleteStub = stub
}

func (fake *FakeClient) WorkspaceDeleteArgsForCall(i int) string {
	fake.workspaceDeleteMutex.RLock()
	defer fake.workspaceDeleteMutex.RUnlock()
	argsForCall := fake.workspaceDeleteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) WorkspaceDeleteReturns(result1 error) {
	fake.workspaceDeleteMutex.Lock()
	defer fake.workspaceDeleteMutex.Unlock()
	fake.WorkspaceDeleteStub = nil
	fake.workspaceDeleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceDeleteReturnsOnCall(i int, result1 error) {
	fake.workspaceDeleteMutex.Lock()
	defer fake.workspaceDeleteMutex.Unlock()
	fake.WorkspaceDeleteStub = nil
	if fake.workspaceDeleteReturnsOnCall == nil {
		fake.workspaceDeleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceDeleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceDeleteWithForce(arg1 string) error {
	fake.workspaceDeleteWithForceMutex.Lock()
	ret, specificReturn := fake.workspaceDeleteWithForceReturnsOnCall[len(fake.workspaceDeleteWithForceArgsForCall)]
	fake.workspaceDeleteWithForceArgsForCall = append(fake.workspaceDeleteWithForceArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.WorkspaceDeleteWithForceStub
	fakeReturns := fake.workspaceDeleteWithForceReturns
	fake.recordInvocation("WorkspaceDeleteWithForce", []interface{}{arg1})
	fake.workspaceDeleteWithForceMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) WorkspaceDeleteWithForceCallCount() int {
	fake.workspaceDeleteWithForceMutex.RLock()
	defer fake.workspaceDeleteWithForceMutex.RUnlock()
	return len(fake.workspaceDeleteWithForceArgsForCall)
}

func (fake *FakeClient) WorkspaceDeleteWithForceCalls(stub func(string) error) {
	fake.workspaceDeleteWithForceMutex.Lock()
	defer fake.workspaceDeleteWithForceMutex.Unlock()
	fake.WorkspaceDeleteWithForceStub = stub
}

func (fake *FakeClient) WorkspaceDeleteWithForceArgsForCall(i int) string {
	fake.workspaceDeleteWithForceMutex.RLock()
	defer fake.workspaceDeleteWithForceMutex.RUnlock()
	argsForCall := fake.workspaceDeleteWithForceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) WorkspaceDeleteWithForceReturns(result1 error) {
	fake.workspaceDeleteWithForceMutex.Lock()
	defer fake.workspaceDeleteWithForceMutex.Unlock()
	fake.WorkspaceDeleteWithForceStub = nil
	fake.workspaceDeleteWithForceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceDeleteWithForceReturnsOnCall(i int, result1 error) {
	fake.workspaceDeleteWithForceMutex.Lock()
	defer fake.workspaceDeleteWithForceMutex.Unlock()
	fake.WorkspaceDeleteWithForceStub = nil
	if fake.workspaceDeleteWithForceReturnsOnCall == nil {
		fake.workspaceDeleteWithForceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceDeleteWithForceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceList() ([]string, error) {
	fake.workspaceListMutex.Lock()
	ret, specificReturn := fake.workspaceListReturnsOnCall[len(fake.workspaceListArgsForCall)]
	fake.workspaceListArgsForCall = append(fake.workspaceListArgsForCall, struct {
	}{})
	stub := fake.WorkspaceListStub
	fakeReturns := fake.workspaceListReturns
	fake.recordInvocation("WorkspaceList", []interface{}{})
	fake.workspaceListMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) WorkspaceListCallCount() int {
	fake.workspaceListMutex.RLock()
	defer fake.workspaceListMutex.RUnlock()
	return len(fake.workspaceListArgsForCall)
}

func (fake *FakeClient) WorkspaceListCalls(stub func() ([]string, error)) {
	fake.workspaceListMutex.Lock()
	defer fake.workspaceListMutex.Unlock()
	fake.WorkspaceListStub = stub
}

func (fake *FakeClient) WorkspaceListReturns(result1 []string, result2 error) {
	fake.workspaceListMutex.Lock()
	defer fake.workspaceListMutex.Unlock()
	fake.WorkspaceListStub = nil
	fake.workspaceListReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WorkspaceListReturnsOnCall(i int, result1 []string, result2 error) {
	fake.workspaceListMutex.Lock()
	defer fake.workspaceListMutex.Unlock()
	fake.WorkspaceListStub = nil
	if fake.workspaceListReturnsOnCall == nil {
		fake.workspaceListReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.workspaceListReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFile(arg1 string, arg2 string) error {
	fake.workspaceNewFromExistingStateFileMutex.Lock()
	ret, specificReturn := fake.workspaceNewFromExistingStateFileReturnsOnCall[len(fake.workspaceNewFromExistingStateFileArgsForCall)]
	fake.workspaceNewFromExistingStateFileArgsForCall = append(fake.workspaceNewFromExistingStateFileArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.WorkspaceNewFromExistingStateFileStub
	fakeReturns := fake.workspaceNewFromExistingStateFileReturns
	fake.recordInvocation("WorkspaceNewFromExistingStateFile", []interface{}{arg1, arg2})
	fake.workspaceNewFromExistingStateFileMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileCallCount() int {
	fake.workspaceNewFromExistingStateFileMutex.RLock()
	defer fake.workspaceNewFromExistingStateFileMutex.RUnlock()
	return len(fake.workspaceNewFromExistingStateFileArgsForCall)
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileCalls(stub func(string, string) error) {
	fake.workspaceNewFromExistingStateFileMutex.Lock()
	defer fake.workspaceNewFromExistingStateFileMutex.Unlock()
	fake.WorkspaceNewFromExistingStateFileStub = stub
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileArgsForCall(i int) (string, string) {
	fake.workspaceNewFromExistingStateFileMutex.RLock()
	defer fake.workspaceNewFromExistingStateFileMutex.RUnlock()
	argsForCall := fake.workspaceNewFromExistingStateFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileReturns(result1 error) {
	fake.workspaceNewFromExistingStateFileMutex.Lock()
	defer fake.workspaceNewFromExistingStateFileMutex.Unlock()
	fake.WorkspaceNewFromExistingStateFileStub = nil
	fake.workspaceNewFromExistingStateFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceNewFromExistingStateFileReturnsOnCall(i int, result1 error) {
	fake.workspaceNewFromExistingStateFileMutex.Lock()
	defer fake.workspaceNewFromExistingStateFileMutex.Unlock()
	fake.WorkspaceNewFromExistingStateFileStub = nil
	if fake.workspaceNewFromExistingStateFileReturnsOnCall == nil {
		fake.workspaceNewFromExistingStateFileReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceNewFromExistingStateFileReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceNewIfNotExists(arg1 string) error {
	fake.workspaceNewIfNotExistsMutex.Lock()
	ret, specificReturn := fake.workspaceNewIfNotExistsReturnsOnCall[len(fake.workspaceNewIfNotExistsArgsForCall)]
	fake.workspaceNewIfNotExistsArgsForCall = append(fake.workspaceNewIfNotExistsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.WorkspaceNewIfNotExistsStub
	fakeReturns := fake.workspaceNewIfNotExistsReturns
	fake.recordInvocation("WorkspaceNewIfNotExists", []interface{}{arg1})
	fake.workspaceNewIfNotExistsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) WorkspaceNewIfNotExistsCallCount() int {
	fake.workspaceNewIfNotExistsMutex.RLock()
	defer fake.workspaceNewIfNotExistsMutex.RUnlock()
	return len(fake.workspaceNewIfNotExistsArgsForCall)
}

func (fake *FakeClient) WorkspaceNewIfNotExistsCalls(stub func(string) error) {
	fake.workspaceNewIfNotExistsMutex.Lock()
	defer fake.workspaceNewIfNotExistsMutex.Unlock()
	fake.WorkspaceNewIfNotExistsStub = stub
}

func (fake *FakeClient) WorkspaceNewIfNotExistsArgsForCall(i int) string {
	fake.workspaceNewIfNotExistsMutex.RLock()
	defer fake.workspaceNewIfNotExistsMutex.RUnlock()
	argsForCall := fake.workspaceNewIfNotExistsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) WorkspaceNewIfNotExistsReturns(result1 error) {
	fake.workspaceNewIfNotExistsMutex.Lock()
	defer fake.workspaceNewIfNotExistsMutex.Unlock()
	fake.WorkspaceNewIfNotExistsStub = nil
	fake.workspaceNewIfNotExistsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceNewIfNotExistsReturnsOnCall(i int, result1 error) {
	fake.workspaceNewIfNotExistsMutex.Lock()
	defer fake.workspaceNewIfNotExistsMutex.Unlock()
	fake.WorkspaceNewIfNotExistsStub = nil
	if fake.workspaceNewIfNotExistsReturnsOnCall == nil {
		fake.workspaceNewIfNotExistsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceNewIfNotExistsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceSelect(arg1 string) error {
	fake.workspaceSelectMutex.Lock()
	ret, specificReturn := fake.workspaceSelectReturnsOnCall[len(fake.workspaceSelectArgsForCall)]
	fake.workspaceSelectArgsForCall = append(fake.workspaceSelectArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.WorkspaceSelectStub
	fakeReturns := fake.workspaceSelectReturns
	fake.recordInvocation("WorkspaceSelect", []interface{}{arg1})
	fake.workspaceSelectMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeClient) WorkspaceSelectCallCount() int {
	fake.workspaceSelectMutex.RLock()
	defer fake.workspaceSelectMutex.RUnlock()
	return len(fake.workspaceSelectArgsForCall)
}

func (fake *FakeClient) WorkspaceSelectCalls(stub func(string) error) {
	fake.workspaceSelectMutex.Lock()
	defer fake.workspaceSelectMutex.Unlock()
	fake.WorkspaceSelectStub = stub
}

func (fake *FakeClient) WorkspaceSelectArgsForCall(i int) string {
	fake.workspaceSelectMutex.RLock()
	defer fake.workspaceSelectMutex.RUnlock()
	argsForCall := fake.workspaceSelectArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeClient) WorkspaceSelectReturns(result1 error) {
	fake.workspaceSelectMutex.Lock()
	defer fake.workspaceSelectMutex.Unlock()
	fake.WorkspaceSelectStub = nil
	fake.workspaceSelectReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) WorkspaceSelectReturnsOnCall(i int, result1 error) {
	fake.workspaceSelectMutex.Lock()
	defer fake.workspaceSelectMutex.Unlock()
	fake.WorkspaceSelectStub = nil
	if fake.workspaceSelectReturnsOnCall == nil {
		fake.workspaceSelectReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.workspaceSelectReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.applyMutex.RLock()
	defer fake.applyMutex.RUnlock()
	fake.currentStateVersionMutex.RLock()
	defer fake.currentStateVersionMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.getPlanFromBackendMutex.RLock()
	defer fake.getPlanFromBackendMutex.RUnlock()
	fake.importMutex.RLock()
	defer fake.importMutex.RUnlock()
	fake.importWithLegacyStorageMutex.RLock()
	defer fake.importWithLegacyStorageMutex.RUnlock()
	fake.initWithBackendMutex.RLock()
	defer fake.initWithBackendMutex.RUnlock()
	fake.initWithoutBackendMutex.RLock()
	defer fake.initWithoutBackendMutex.RUnlock()
	fake.jSONPlanMutex.RLock()
	defer fake.jSONPlanMutex.RUnlock()
	fake.outputMutex.RLock()
	defer fake.outputMutex.RUnlock()
	fake.outputWithLegacyStorageMutex.RLock()
	defer fake.outputWithLegacyStorageMutex.RUnlock()
	fake.planMutex.RLock()
	defer fake.planMutex.RUnlock()
	fake.savePlanToBackendMutex.RLock()
	defer fake.savePlanToBackendMutex.RUnlock()
	fake.setModelMutex.RLock()
	defer fake.setModelMutex.RUnlock()
	fake.statePullMutex.RLock()
	defer fake.statePullMutex.RUnlock()
	fake.versionMutex.RLock()
	defer fake.versionMutex.RUnlock()
	fake.workspaceDeleteMutex.RLock()
	defer fake.workspaceDeleteMutex.RUnlock()
	fake.workspaceDeleteWithForceMutex.RLock()
	defer fake.workspaceDeleteWithForceMutex.RUnlock()
	fake.workspaceListMutex.RLock()
	defer fake.workspaceListMutex.RUnlock()
	fake.workspaceNewFromExistingStateFileMutex.RLock()
	defer fake.workspaceNewFromExistingStateFileMutex.RUnlock()
	fake.workspaceNewIfNotExistsMutex.RLock()
	defer fake.workspaceNewIfNotExistsMutex.RUnlock()
	fake.workspaceSelectMutex.RLock()
	defer fake.workspaceSelectMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ terraform.Client = new(FakeClient)
